{
  "name": "extdirect",
  "version": "1.1.1",
  "description": "Ext.Direct connector for Sencha Touch/ExtJs",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:jurisv/extdirect.git"
  },
  "keywords": [
    "ext",
    "direct",
    "sencha",
    "touch",
    "extjs",
    "extdirect",
    "remoting",
    "rpc",
    "connector",
    "api"
  ],
  "author": {
    "name": "Juris Vecvanags"
  },
  "license": "BSD",
  "readmeFilename": "README.md",
  "readme": "### Sencha Ext.Direct connector for node.js\n\n### Compatibility:\n* Sencha Touch 2.1.x / 2.2 /2.3 beta\n* ExtJs 4.2.x\n\n### Server side implementation:\n\nStep1: Create the folder where your node.js server will reside and then add the following file/folder structure:\n\n````\n/app.js\n/config.json\n/package.json\n/public -> here you generate Sencha Touch/ ExtJs application using Sencha CMD\n/direct -> here you will place all Ext.Direct files\n/uploads -> file upload folder (must be writable by node.js)\n````\n\nStep 2: Edit app.js content to match example below:\nNote: This example is using MySQL database\n#### File app.js:\n\n````\nvar express = require('express'),\n    nconf = require('nconf'),\n    http = require('http'),\n    path = require('path'),\n    mysql = require('mysql'),\n    extdirect = require('extdirect');\n\nnconf.env().file({ file: 'config.json'});\n\nvar ServerConfig = nconf.get(\"ServerConfig\"),\n    MySQLConfig = nconf.get(\"MySQLConfig\"),\n    ExtDirectConfig = nconf.get(\"ExtDirectConfig\");\n\nvar app = express();\n\nif(ServerConfig.enableSessions){\n    //memory store for sessions - change to different storage here to match your implementation.\n    var store  = new express.session.MemoryStore;\n}\n\nvar mySQL = {\n    connect : function(){\n        var conn = mysql.createConnection({\n            host: MySQLConfig.hostname,\n            port: MySQLConfig.port,\n            user: MySQLConfig.user,\n            password: MySQLConfig.password,\n            database: MySQLConfig.db\n        });\n\n        conn.connect(function(err) {\n            if(err){\n                console.error('Connection had errors: ', err.code);\n                process.exit(1);\n            }\n        });\n\n        return conn;\n    },\n\n    disconnect : function(conn){\n        conn.end();\n    }\n};\n\n// Make MySql connections available globally, so we can access them from within modules\nglobal['mySQL'] =  mySQL;\n\napp.configure(function(){\n\n    app.set('port', process.env.PORT || ServerConfig.port);\n    app.use(express.logger(ServerConfig.logger));\n\n    if(ServerConfig.enableUpload){\n        app.use(express.bodyParser({uploadDir:'./uploads'})); //take care of body parsing/multipart/files\n    }\n\n    app.use(express.methodOverride());\n\n    if(ServerConfig.enableCompression){\n        app.use(express.compress()); //Performance - we tell express to use Gzip compression\n    }\n\n    if(ServerConfig.enableSessions){\n        //Required for session\n        app.use(express.cookieParser());\n        app.use(express.session({ secret: ServerConfig.sessionSecret, store: store }));\n    }\n\n    app.use(express.static(path.join(__dirname, ServerConfig.webRoot)));\n});\n\n//Important to get CORS headers and cross domain functionality\nif(ServerConfig.enableCORS){\n    app.all('*', function(req, res, next) {\n        res.header(\"Access-Control-Allow-Origin\", \"*\");\n        res.header(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\");\n        next();\n    });\n\n    app.options(ExtDirectConfig.classPath, function(request, response) {\n        response.writeHead(200, {'Allow': ServerConfig.allowedMethods});\n        response.end();\n    });\n}\n\n//GET method returns API\napp.get(ExtDirectConfig.apiPath, function(request, response) {\n    try{\n        var api = extdirect.getAPI(ExtDirectConfig);\n        response.writeHead(200, {'Content-Type': 'application/json'});\n        response.end(api);\n    }catch(e){\n        console.log(e);\n    }\n});\n\n// Ignoring any GET requests on class path\napp.get(ExtDirectConfig.classPath, function(request, response) {\n    response.writeHead(200, {'Content-Type': 'application/json'});\n    response.end(JSON.stringify({success:false, msg:'Unsupported method. Use POST instead.'}));\n});\n\n// POST request process route and calls class\napp.post(ExtDirectConfig.classPath, function(request, response) {\n    extdirect.processRoute(request, response, ExtDirectConfig);\n});\n\napp.configure('development', function(){\n    app.use(express.errorHandler({ dumpExceptions: true, showStack: true }));\n});\n\napp.configure('production', function(){\n    app.use(express.errorHandler());\n});\n\nhttp.createServer(app).listen(app.get('port'), function(){\n    console.log(\"Express server listening on port %d in %s mode\", app.get('port'), app.settings.env);\n});\n\n````\n#### File package.json:\n````\n{\n    \"name\": \"touch-direct\",\n    \"version\": \"1.0.0\",\n    \"private\": true,\n    \"scripts\": {\n        \"start\": \"node app\"\n    },\n    \"repository\": {\n        \"type\": \"git\",\n        \"url\": \"\"\n    },\n    \"dependencies\": {\n        \"express\": \"3.1.0\",\n        \"nconf\": \"~0.6.7\",\n        \"mysql\": \"~2.0.0\",\n        \"extdirect\":\"~1.1.0\"\n    }\n}\n````\nStep 3: Edit config.json file:\n\nIf you don't use Mysql or have any other database e.g. MongoDb, you can exclude config property related to database, but then be sure to take away all related code in app.js . It still might be a good idea to keep all Db config properties in this file.\n<b>Important:</b> Since version 1.1.0 all properties are stored in this config file and there is no need to update app.js if you are using vanilla reference implementation.\nUpdate config parameters that are relevant to your implementation.\n\n#### File config.json\n````\n{\n    \"ServerConfig\": {\n        \"port\": 3000,\n        \"logger\": \"dev\",\n        \"enableUpload\": true,\n        \"enableCompression\": true,\n        \"webRoot\": \"/public\",\n        \"enableSessions\": true,\n        \"sessionSecret\": \"vdW3F6y3506h\",\n        \"enableCORS\": true,\n        \"allowedMethods\": \"GET,POST,OPTIONS\"\n    },\n\n    \"MySQLConfig\": {\n        \"hostname\": \"localhost\",\n        \"port\": 3306,\n        \"user\": \"script\",\n        \"password\": \"JxJSNa3stRYSV68j\",\n        \"db\": \"demo\"\n    },\n\n    \"ExtDirectConfig\": {\n        \"namespace\": \"ExtRemote\",\n        \"apiName\": \"REMOTING_API\",\n        \"apiPath\": \"/directapi\",\n        \"classPath\": \"/direct\",\n        \"classPrefix\": \"DX\",\n        \"server\": \"localhost\",\n        \"port\": \"3000\",\n        \"protocol\": \"http\"\n    }\n}\n````\nStep 4: Create and modify your Sencah Touch / ExtJs application.\n\n### *** Touch application modifications ***\n\nFor you Sencha touch application you have to add the following lines inside Touch application main /public/app.js file, just before Ext.application code:\n````\nExt.require([\n    'Ext.direct.*'\n]);\n\nExt.onReady(function(){\n    Ext.direct.Manager.addProvider(ExtRemote.REMOTING_API); //Must match namespace and apiName defined in node.js server\n});\n\n//Ext.application({\n//.. your app code here\n\n````\n\n/public/index.html(add the line for requesting API): \n````\n<!-- The line below must be kept intact for Sencha Command to build your application -->\n    <script id=\"microloader\" type=\"text/javascript\" src=\"touch/microloader/development.js\"></script>\n    <script type=\"text/javascript\" src=\"/directapi\"></script>\n````\n### *** Sample direct methods ***\nCreate file /direct/DXTodoItem.js :\n````\nvar table = 'todoitem';\nvar mysql = mySQL;\n\nvar DXTodoItem  = {\n    create: function(params, callback){\n        var conn = mysql.connect();\n        delete params['id'];\n        conn.query('INSERT INTO ' + table + ' SET ?', params, function(err, result) {\n            mysql.disconnect(conn); //release connection\n            if (err) throw err;\n\n            conn.query('SELECT * FROM '  + table + ' WHERE id = ?', result.insertId, function(err, rows, fields) {\n                callback(rows);\n            });\n        });\n    },\n\n    //callback as last argument is mandatory\n    read: function(params, callback){\n        var conn = mysql.connect();\n\n        var sql = 'SELECT * from ' + table;\n        // this sample implementation supports 1 sorter, to have more than one, you have to loop and alter query\n        if(params.sort){\n            var s = params.sort[0];\n            sql = sql + ' order by ' + conn.escape(s.property) +  ' ' + conn.escape(s.direction);\n        }\n\n        // Paging\n        sql = sql + ' limit ' + conn.escape(params.start) + ' , ' + conn.escape(params.limit);\n\n        conn.query(sql, function(err, rows, fields) {\n            if (err) throw err;\n\n            //get totals for paging\n\n            var totalQuery = 'SELECT count(*) as totals from ' + table;\n\n            conn.query(totalQuery, function(err, rowsTotal, fields) {\n                mysql.disconnect(conn); //release connection\n                if (err) throw err;\n\n                callback({\n                    success: true,\n                    data: rows,\n                    total: rowsTotal[0].totals\n                });\n            });\n        });\n    },\n\n    update: function(params, callback){\n        var conn = mysql.connect();\n\n        conn.query('UPDATE ' + table + ' SET ? where id = ' + conn.escape(params['id']), params, function(err, result) {\n            mysql.disconnect(conn); //release connection\n            if (err) throw err;\n            callback({success:true});\n        });\n    },\n\n    destroy: function(params, callback){\n        var conn = mysql.connect();\n\n        conn.query('DELETE FROM ' + table + ' WHERE id = ?', conn.escape(params['id']), function(err, rows, fields) {\n            if (err) throw err;\n            mysql.disconnect(conn); //release connection\n            callback({success:true, id:params['id']});\n        });\n    }\n};\n\nmodule.exports = DXTodoItem;\n````\n\n### *** Configure your application model with direct proxy  ***\n````\nExt.define('TouchDirect.model.TodoItem', {\n    extend: 'Ext.data.Model',\n    config: {\n        idProperty: 'id',\n        fields: [{\n            name: 'id',\n            type: 'int'\n        }, {\n            name: 'text',\n            type: 'string'\n        }, {\n            name: 'complete',\n            type: 'boolean'\n        }],\n\n        proxy: {\n            //Set proxy type\n            type: 'direct',\n\n            //Define action methods\n            api: {\n                create  : ExtRemote.DXTodoItem.create,\n                read    : ExtRemote.DXTodoItem.read,\n                update  : ExtRemote.DXTodoItem.update,\n                destroy : ExtRemote.DXTodoItem.destroy\n            }\n        }\n    }\n});\n````\n\n###  *** ExtJS Application modifications ***\n\nFor your ExtJs app add in /public/app.js :\n````\nExt.require([\n    'Ext.direct.*'\n]);\n\nExt.onReady(function(){\n    Ext.direct.Manager.addProvider(ExtRemote.REMOTING_API);\n});\n````\n\n#### Index file /public/index.html  add script containing directapi.\n````\n<!DOCTYPE HTML>\n<html>\n<head>\n    <meta charset=\"UTF-8\">\n    <title>DesktopDirect</title>\n    <!-- <x-compile> -->\n        <!-- <x-bootstrap> -->\n            <link rel=\"stylesheet\" href=\"bootstrap.css\">\n            <script src=\"ext/ext-dev.js\"></script>\n            <script src=\"bootstrap.js\"></script>\n        <!-- </x-bootstrap> -->\n        <script src=\"app.js\"></script>\n    <!-- </x-compile> -->\n    <script src=\"/directapi\"></script>\n</head>\n<body></body>\n</html>\n````\n\nThen for your directCfg, and api definitions use string literals of methods,\nlike this:\n\nForm:\n````\napi:{\n      load: 'ExtRemote.DXFormTest.load',\n      submit:'ExtRemote.DXFormTest.submit'\n}\n````\nGrid store with directFn:\n\n````\nstore: {\n            model: 'Company',\n            remoteSort: true,\n            autoLoad: true,\n            sorters: [{\n                property: 'name',\n                direction: 'ASC'\n            }],\n            proxy: {\n                type: 'direct',\n                directFn: 'TestAction.getGrid'\n            }\n        },\n````\nEven more interesting is the file upload case:\n\n#### ExtJs config\n````        \n        {\n                        xtype:'form',\n                        title: 'File upload',\n                        bodyPadding:5,\n                        api:{\n                            submit:'ExtRemote.DXFormTest.filesubmit'\n                        },\n                        paramOrder: ['uid'],\n                        items:[\n                            {\n                                xtype:'textfield',\n                                fieldLabel:'Description',\n                                name:'description'\n                            },\n                            {\n                                xtype: 'filefield',\n                                name: 'photo',\n                                fieldLabel: 'Photo',\n                                labelWidth: 50,\n                                msgTarget: 'side',\n                                allowBlank: true,\n                                anchor: '40%',\n                                buttonText: 'Select Photo...'\n                            }\n                        ],\n                        tbar:[\n                            {\n                                text:'Upload..',\n                                handler:function(btn){\n                                    btn.up('form').getForm().submit(\n                                        {\n                                            waitMsg: 'Uploading your photo...',\n                                            success: function(fp, o) {\n                                                Ext.Msg.alert('Success', 'Your photo \"' + o.result.name +\n                                                    '\" has been uploaded.<br> File size:' + o.result.size + ' bytes.');\n                                            }\n                                        }\n                                    );\n                                }\n                            }\n                        ]\n                    }\n````\n\n### node.js sample for upload/submit/test/load\n\n#### File:DXFormTest\n````\nvar DXFormTest = {\n    testMe: function(params, callback){\n        callback({\n            success:true,\n            msg:'Hello world',\n            params: params\n        });\n    },\n\n    load: function(params, callback){\n        callback({\n            success:true,\n            data:{\n                firstname:'John',\n                lastname: 'Smith',\n                email: 'john.smith@comapny.info'\n            }\n        });\n    },\n\n    submit: function(params,  callback/*formHandler*/){\n        callback({\n            success:true,\n            params:params\n        });\n\n    },\n````\nWhen dealing with forms that submit via submit api method or upload a file,\nremember to mark your method with formHandler, as shown below\n````\n    filesubmit: function(params, files, callback/*formHandler*/){\n            // console.log(params, files)\n\n            // Do something with uploaded file, e.g. move to another location\n            var fs = require('fs'),\n                file = files.photo,\n                tmp_path = file.path;\n\n            // set where the file should actually exists - in this case it is in the \"demo\" directory\n            var target_path = './public/demo/' + file.name;\n\n            // move the file from the temporary location to the intended location\n            // do it only if there is a file with size\n            if(file.size > 0){\n                try{\n                    fs.rename(tmp_path, target_path, function(err) {\n                        if(err){\n                            callback({\n                                success: false,\n                                msg: 'Upload failed',\n                                errors: err.message\n                            });\n                        }\n                        // delete the temporary file, so that the explicitly set temporary upload dir does not get filled with unwanted files\n                        fs.unlink(tmp_path, function() {\n                            callback({\n                                success: true,\n                                msg: 'Uploaded successfully',\n                                size: file.size,\n                                name: file.name\n                            });\n                        });\n                    });\n                }catch(e) {\n                    callback({\n                        success: false,\n                        msg: 'Upload failed',\n                        errors: e.message\n                    });\n                }\n            }else{\n                callback({\n                    success: false,\n                    msg: 'No file',\n                    params: params\n                });\n            }\n        }\n};\n\nmodule.exports = DXFormTest;\n````\n\nNOTE: Remember, that you can always invoke server-side methods if you need them, and receive the response inside the callback.\nThis way you are not limited to existing prebuilt use cases in different widgets.\nSample call would be simple as this:\n````\nExtRemote.DXFormTest.testMe(3,\n    function(res){\n        console.dir(res);\n    }\n);\n\n````\n\n### Basic serverside methods and their callbacks\n````\n   //regular functions MUST call callback.\n    regularFunction: function(params, callback){\n        callback({msg: params});\n    },\n\n    //sample that shows usage of event instead of RPC response\n    messageFunction: function(params, callback){\n        callback({}, 'message'); // add second parameter to callback, this way it wil be converted to event\n    },\n\n    customErrorFunction: function(params, callback){\n        throw new Error(\"Something wrong happened\"); // error handling is now fully supported\n\n        //notice that in the case of error no callback will be invoked\n\n        //if there will be other methods in batch, processing will continue for next transaction\n    }\n````\n\n### Session support\n\nAs of version 1.1.0 sessions are supported within reference implementation. Set enableSessions to true.\nWhen session support is enabled, all methods will be feed with extra last argument which has sessionID.\nYou have to implement authentication and session handling process according to your business requirements.\nExample code:\n\n````\nvar DXLogin  = {\n// callback as last argument and mandatory\n// If session support is enabled globally, then there will be the 3rd argument accessible via arguments[arguments.length-1]\n\n    authenticate: function(params, callback){\n//      var username = params.username;\n//      var password = params.password;\n        console.log(arguments[arguments.length-1]); //this holds sessionID !\n\n        /*\n        Some code here to check login\n        */\n        callback({success:true, message:'Login successful'});\n    }\n};\n\nmodule.exports = DXLogin;\n````\n\nFor more use cases please refer to ExtJs documentation.\n\n## Server 'production' vs 'development' mode\nBy default Your node.js server is working in development mode, thus effectively spitting out a lot of useful dev-time info.\nAs of version 1.0.0 connector will look at the mode and change its behavior upon selection. \nFor development mode it will return packets of type 'exception' whenever it will encounter one.\nFor production mode, instead it will return blank 'rpc' packet.\n\nTo change mode you have to set environment variable NODE_ENV to production.\nThere are 2 options.\n1) in Terminal run the command: export NODE_ENV=production\n2) Add permamently to your .bash_profile file:\n````\necho export NODE_ENV=production >> ~/.bash_profile\nsource ~/.bash_profile\n````\n\n\n### Changelog:\n* 1.1.1 (15 oct 2013)\n        Update Docs. Fix MySQL examples to prevent SQL Injection vulnerabilities.\n\n* 1.1.0 (24 aug 2013)\n\n        Update docs and sample server-side code to include CORS support\n        Configs for protocol, server, port\n        Refactor to pass one config object instead of multiple parameters\n        New config parameters.\n        Renamed some configs that were confusing. Check ExtDirectConfig config.\n        <b>Important</b> Upgrade from v1.0.0:\n        Adjust node.js main app.js and config.json files. Router and Api functions now expect config object instead of separate ordered parameters.\n\n* 1.0.0 (18 july 2013)\n\n        Announced and pushed to npmjs repository\n\n* 1.0.0 (26 jun 2013)\n\n        Limit exception type of packets to development mode only\n        Add info on development/production mode settings in docs\n        \n* 0.9.9 (19 jun 2013)\n\n        Added Windows support\n\n* 0.9.8 (18 jun 2013)\n\n        Added Session support plus examples\n        Added Proper error handling- failed transactions will be returned as exceptions        \n        Added Event support\n\n* 0.9.7 (26 mar 2013)\n\n        Fixed Markdown in Docs\n\n* 0.9.6 (25 Mar 2013)\n\n        Add form handling\n        Add form file upload feature\n        Add API generation caching\n        Gracefully handle errors\n        Add Code samples in README.md        \n\n* 0.9.5 Minimal stable\n\n* 0.9.0 Public release",
  "bugs": {
    "url": "https://github.com/jurisv/extdirect/issues"
  },
  "_id": "extdirect@1.1.1",
  "dist": {
    "shasum": "3274dbea8b2c4e2956da72fdc7c1efd5cd067bc7"
  },
  "_from": "extdirect@~1.1.0",
  "_resolved": "https://registry.npmjs.org/extdirect/-/extdirect-1.1.1.tgz"
}
